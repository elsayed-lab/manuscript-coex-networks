#### Infected vs. Uninfected Difference Matrix

```{r difference_heatmap}
diff <- inf - uninf

# sub-sample to speed up and better fit in display
ind <- sample(1:nrow(diff), 750)

heatmap.2(diff[ind, ind], trace='none', dendrogram='row', labRow=FALSE, labCol=FALSE,
          col='plasma', main=sprintf('Difference Network Adjacency Matrix:\n%s', subtitle),
          margin=c(6, 6), xlab='Gene', ylab='Gene', density='none',
          #key=FALSE,
          key.title='', key.ylab='', keysize=2,
          key.xlab='Edge Weight\n (Infected - Uninfected)')

```

```{r diff_matrix_clustering}
# convert to distance matrix and perform hierarchical clustering
# take absolute value of difference adjacency matrix; sets of genes which are
# all changing direction together, will still be separated out
#distmat <- 1 - abs(diff)

# TESTING 2017/12/01
distmat <- (1 + diff) / 2

gene_tree <- flashClust(as.dist(distmat), method="average")
gene_tree$height <- round(gene_tree$height, 6)

# perform dynamic tree-cut based clustering
module_labels <- cutreeDynamicTree(dendro=gene_tree, deepSplit=FALSE, minModuleSize=10)

num_labels <- length(unique(module_labels))
pal <- c('grey', substring(rainbow(num_labels), 1, 7))
module_colors <- (pal[module_labels + 1])

module_mapping <- tbl_df(cbind(gene_id=rownames(diff), module=module_colors))

# create a mapping from module id to number of genes for later use
module_sizes <- setNames(as.data.frame(module_colors), 'module_id') %>% 
    group_by(module_id) %>% 
    summarize(num_genes=n())

num_modules <- length(unique(module_colors))

# cpm-transform raw counts
cpm_counts <- sweep(count_table, 2, colSums(count_table), '/') * 1E6
cpm_counts <- cpm_counts[rownames(cpm_counts) %in% gene_tree$labels,]

log2cpm_counts <- log2(cpm_counts + 1)

combined_gene_counts <- combine_replicates(log2cpm_counts, condition)

#counts_long <- cbind(gene_id=rownames(count_table), log2cpm_counts)
#counts_long <- melt(counts_long, id.vars='gene_id')
counts_long <- melt(combined_gene_counts, id.vars='row.names')

names(counts_long) <- c('gene_id', 'condition', 'expression')

# Human-readable labels
expr_xlab <- "Condition"

if ("CONFIG_EXTRA" %in% ls()) {
    mapping <- CONFIG_EXTRA$condition_mapping
    counts_long$condition <- mapping$short[match(counts_long$condition, mapping$long)]

    expr_xlab <- CONFIG_EXTRA$xlabel
}

# If non-numeric conditions (e.g. 'procyclic') are included, convert to
# factor and reorder levels of dataframe for better plotting
if (!is.numeric(counts_long$condition)) {
    counts_long$condition <- factor(counts_long$condition)
}

counts_long <- cbind(counts_long, cluster=as.factor(module_colors))
module_order <- unique(module_colors[gene_tree$order])
```

```{r module_stats, results='asis'}
cat(sprintf("- Number of modules: %d\n", num_modules))
cat(sprintf("- Median module size: %0.1f\n", median(module_sizes$num_genes)))
cat(sprintf("- Largest module size: %d\n", max(module_sizes$num_genes)))
```

#### Functional Enrichment

```{r create_net_annotation_df}
# load relevant gene annotations and restore order
gene_info <- gene_info_orig %>% 
    filter(gene_id %in% rownames(diff)) %>%
    arrange(gene_id)

result <- cbind(gene_info, color=module_colors)
annot <- cbind(gene_info, color=module_colors, cluster=module_labels)
```

##### GO Enrichment

```{r child='../../../2015/00-shared/Rmd/results/go_enrichment_network.Rmd'}
```

##### KEGG Enrichment

```{r child='../../../2015/00-shared/Rmd/results/kegg_enrichment_network.Rmd'}
```

```{r child='02-kegg-enrichment-results.Rmd'}
```

##### CPDB Enrichment

```{r child='../../../2015/00-shared/Rmd/results/cpdb_enrichment_network.Rmd'}
```

```{r child='02-cpdb-enrichment-results.Rmd'}
```

##### TF regulon Enrichment

```{r child='../../../2015/00-shared/Rmd/results/hsapiens_marbach2016_tf_enrichment.Rmd'}
```

```{r child='02-tf-regulon-enrichment-results.Rmd'}
```

##### Visualization of enriched rewired subnetworks

```{r enriched_difference_subnetwork, results='asis'}
cat('\n')

for (module_color in unique(c(enriched_colors_go, enriched_colors_kegg))) {
    # show diff network
    cat(sprintf("##### %s\n\n", module_color))
    genes <- (result %>% filter(color==module_color))$gene_id
    ind <- rownames(diff) %in% genes

    # create graph instance
    g <- graph.adjacency(diff[ind, ind], mode='undirected', weighted=TRUE)

    # get sum of edge weights for each vertex and rescale to range [-1, 1]
    edge_flux <- graph.strength(g)
    edge_flux <- edge_flux / max(abs(edge_flux))

    # color vertices based on net edge flux
    pal_neg <- colorRamp(c('purple', 'red'))
    pal_pos <- colorRamp(c('purple', 'blue'))

    V(g)$color <- sapply(edge_flux, FUN=function(x) {
        if (x < 0) {
            rgbcol <- pal_neg(abs(x))
        } else {
            rgbcol <- pal_pos(x)
        }
        rgb(rgbcol[1], rgbcol[2], rgbcol[3], 128, maxColorValue=255)
    })

    # color edges based on direction of change (red = neg, blue = pos)
    E(g)$color <- ifelse(E(g)$weight < 0, rgb(1,0,0,0.5), rgb(0,0,1,0.5))
    E(g)$weight <- abs(E(g)$weight)

    # remove low-weight edges (keep an average of 3 edges per node)
    num_edges <- 3 * length(V(g))

    if (num_edges < length(E(g))) {
        cutoff <- as.numeric(quantile(E(g)$weight, 1 - (num_edges / length(E(g)))))

        E(g)$weight[E(g)$weight < cutoff] <- 0
        g <- delete.edges(g, which(E(g)$weight==0))

        # remove nodes that become disconnected
        g <- delete.vertices(g, which(degree(g) == 0))
    }

    # relabel
    vlabels <- gene_info[match(names(V(g)), gene_info$gene_id),]$description

    # rescale edge weights
    E(g)$weight <- E(g)$weight - min(E(g)$weight)
    E(g)$weight <- ((E(g)$weight / max(E(g)$weight))) * 5

    layout_coords <- layout.fruchterman.reingold(g)

    V(g)$label.cex   <- 0.7
    V(g)$label.color <- '#333333'

    # network plot
    plot(g, layout=layout_coords, vertex.size=5, vertex.label=vlabels,
         vertex.label.dist=1,
         edge.width=E(g)$weight)

    # heatmap plot
    adj <- diff[ind,ind]

    # create diverging color ramp centered about 0 for heatmap
    # https://stackoverflow.com/questions/10985224/r-heatmap-with-diverging-colour-palette/10986203#10986203
    ncols <- 100
    ramp_cols <- colorRampPalette(colors=c('red', 'purple', 'blue'), space="Lab")(ncols)

    ## Make a vector with n+1 breaks
    ramp_breaks <- seq(-max(abs(adj)), max(adj), length.out=ncols+1)

    heatmap.2(adj, trace='none', dendrogram='row', cexRow=30/nrow(adj),
              labRow=gene_info$description[ind], margins=c(6, 16),
              labCol=FALSE, col=ramp_cols, breaks=ramp_breaks,
              xlab='Gene', ylab='Gene', density='none',
              key.title='', key.ylab='',  keysize=2,
              key.xlab='Edge Weight\n (Infected - Uninfected)')
}
```

```{r save_network, message=FALSE}
message("Saving difference network GraphML...")

# rescale edge weights to [-1, 1] and save network
#diff <- log1p(diff)
diff <- diff / max(abs(diff))

message("CURRENT DIR")
message(getwd())
outfile <- file.path('..', output_datadir, paste0('difference_network_', output_suffix, '.graphml'))

# annotations
annot <- cbind(gene_info, color=module_colors, cluster=module_labels)

g <- export_network_to_graphml(diff,
                               outfile,
                               threshold=0, max_edge_ratio=4,
                               nodeAttrDataFrame=annot)
```

```{r cleanup, include=FALSE}
rm(g, inf, uninf, distmat)
```

