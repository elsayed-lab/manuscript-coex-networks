## Consensus co-expression network construction

To begin with, previously generated adjaceny matrices from multiple different
network parameterizations are loaded and combined into a single "consensus
adjacency matrix".

Each cell in the matrix represents the total support for a co-expression
relationship between two genes across a large number of alternative network
instantiations.

```{r load_consensus_nets, message=FALSE, cache=TRUE, cache.lazy=FALSE, autodep=TRUE}
# input adjaceny matrices
input_nets <- Sys.glob(file.path(MANUSCRIPT_CONFIG$input_dir, '*_adjmat.RData'))
input_rdas <- sub('_adjmat', '', input_nets)

# filter input nets and rdas (optional)
if ('networks' %in% names(MANUSCRIPT_CONFIG)) {
    nets_to_include <- sprintf('%d_adjmat.RData', MANUSCRIPT_CONFIG$networks$id)
    rdas_to_include <- sprintf('%d.RData', MANUSCRIPT_CONFIG$networks$id)

    input_nets <- input_nets[basename(input_nets) %in% nets_to_include] 
    input_rdas <- input_rdas[basename(input_rdas) %in% rdas_to_include] 
}

# empty vectors to keep track of network metrics
ratio_nonzero_edges  <- c()
ratio_edges_1q       <- c()
ratio_edges_2q       <- c()
ratio_edges_3q       <- c()
median_edge_weight_global   <- c()

# Note: for performance purposes, we will hold off converting the stored upper triangular 
# adjacency matrix values until the very last step. 
# We will limit ourselves to only those genes found in all networks; currently,
# there are few parameters which affect the total number of genes in the network, and as such,
# there are likely only a few possible combinations of genes present. To avoid having to convert
# the adj mat upper triangular values back into a matrix (slow for large adjacency matrices) each 
# time to determine which entries need to be removed, we will instead maintain multiple separate 
# "sub" consensus vectors; one for each gene subset present. After all of the matrices have been
# loaded, we will then convert each configuration back in to a matrix and remove genes not
# present in all networks, before combining into a final consensus network.

# Example (HsTc v7.0)
# > table(x$num_genes)
# 29109 29148 29219 
#  224   224   896 
#

# lists to keep track of sub-consensus networks associated with each gene configuration present
# (typically only three such configurations present for a given dataset)
adjmats <- list()
modmaps <- list()

# iterate over remaining networks and add to consensus net
#
for (i in 1:length(input_nets)) {
    # load saved data
    message(sprintf("Loading network %d/%d (%s)", i, length(input_nets), basename(input_nets[i])))
    message(sprintf("1. %s", Sys.time()))

    load(input_nets[i])
    load(input_rdas[i])

    message(sprintf("2. %s", Sys.time()))

    # check to make sure dimensions are as expected (a few adjacency matrices
    # in the past were corrupted, leading to issues; the problem has since been fixed
    # upstream and should no longer occur, but leaving check just to be safe..)
    matsize <- nrow(module_mapping)

    if ((((matsize * matsize) - matsize) / 2) != length(adjacency_matrix)) {
        warning(sprintf("Dimension mismatch for adjacency matrix: %s", input_rdas[i]))
        stop(sprintf("Incompatible adjacency matrix input: %s", input_nets[i]))
    }

    # ratio of non-zero edges (global)
    ratio_nonzero_edges <- c(ratio_nonzero_edges, sum(adjacency_matrix != 0) /
                             length(adjacency_matrix))

    # ratio of edges with values > 0.25, 0.50, 0.75 of the maximum edge weight
    scaled_adjmat <- adjacency_matrix / max(adjacency_matrix)

    ratio_edges_1q <- c(ratio_edges_1q, sum(scaled_adjmat > 0.25) / length(scaled_adjmat))
    ratio_edges_2q <- c(ratio_edges_2q, sum(scaled_adjmat > 0.50) / length(scaled_adjmat))
    ratio_edges_3q <- c(ratio_edges_3q, sum(scaled_adjmat > 0.75) / length(scaled_adjmat))

    message(sprintf("3. %s", Sys.time()))

    # median non-zero edge weight value (global)
    median_edge_weight_global <- c(median_edge_weight_global, 
                                   median(adjacency_matrix[adjacency_matrix != 0]))

    message(sprintf("4. %s", Sys.time()))

    # normalize edge weights
    if ('normalization' %in% names(MANUSCRIPT_CONFIG)) {
        if (MANUSCRIPT_CONFIG$normalization == 'scale') {
            # size-factor normalization
            adjacency_matrix <- (adjacency_matrix / sum(adjacency_matrix)) * 1E6
        } else if (MANUSCRIPT_CONFIG$normalization == 'rank') {
            # rank-based normalization
            adjacency_matrix <- data.table::frank(adjacency_matrix) * 1E-5
        }
    }

    message(sprintf("5. %s", Sys.time()))

    # add to consensus sub-matrix
    key <- digest(sort(module_mapping$gene_id), algo = 'md5')

    if (!key %in% names(adjmats)) {
        # new gene configuration
        adjmats[[key]] <- adjacency_matrix
        modmaps[[key]] <- module_mapping
    } else {
        # existing gene configuration
        adjmats[[key]] <- adjmats[[key]] + adjacency_matrix
    }
    message(sprintf("6. %s", Sys.time()))
}

# determine which genes are present in all networks
shared_genes <- sort(Reduce(intersect, lapply(modmaps, '[[', 'gene_id')))

# create empty adjacency matrix with expected dimensions
adjmat <- matrix(0, nrow = length(shared_genes), ncol = length(shared_genes))

rownames(adjmat) <- shared_genes
colnames(adjmat) <- shared_genes

# iterate over gene configurations and add to combined (final) consensus adjacency matrix
for (key in names(adjmats)) {
    # get module mapping
    module_mapping <- modmaps[[key]]

    # convert upper triangular matrix values back into full matrix
    matsize <- nrow(module_mapping)

    # convert upper.tri weight vector back into adj matrix (normalized)
    tmp <- matrix(0, nrow = matsize, ncol = matsize)
    tmp[upper.tri(tmp)] <- adjacency_matrix

    rownames(tmp) <- module_mapping$gene_id
    colnames(tmp) <- module_mapping$gene_id

    # drop non-shared genes, if present
    tmp <- tmp[rownames(tmp) %in% shared_genes, colnames(tmp) %in% shared_genes]

    # rows and columsn should already be in sorted order, but just to be safe...
    if (rownames(tmp) != rownames(adjmat)) {
        stop("Mismatched adjacency matrix entries!")
    }

    # add to combined matrix
    adjmat <- adjmat + tmp
}

# fill in lower triangular part of adjacency matrix (symmetric)
adjmat[lower.tri(adjmat)] <- t(adjmat)[lower.tri(adjmat)]

# histogram of the consensus adj matrix edge weight distribution
#hist(log1p(adjmat))
hist(adjmat, main="Distribution of consensus adjacency matrix edge weights",
     xlab="Edge weight")
```

```{r save_rdata}
# save RData files to output dir
save(adjmat, file=file.path(output_datadir, paste0('adjmat_', output_suffix, '.rda')))

# 2017/12/25: disabling filtering-related results for now
#save(dat, dat_num_unique,  dat_ratio_enrichment,
#     file=file.path(output_datadir, paste0('results_', output_suffix, '.rda')))

gc()
```


