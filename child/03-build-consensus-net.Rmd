## Consensus co-expression network construction

To begin with, previously generated adjaceny matrices from multiple different
network parameterizations are loaded and combined into a single "consensus
adjacency matrix".

Each cell in the matrix represents the total support for a co-expression
relationship between two genes across a large number of alternative network
instantiations.

```{r load_consensus_nets, message=FALSE, cache=TRUE, cache.lazy=FALSE, autodep=TRUE}
# input adjaceny matrices
input_nets <- Sys.glob(file.path(MANUSCRIPT_CONFIG$input_dir, '*_adjmat.RData'))
input_rdas <- sub('_adjmat', '', input_nets)

# filter input nets and rdas (optional)
if ('networks' %in% names(MANUSCRIPT_CONFIG)) {
    nets_to_include <- sprintf('%d_adjmat.RData', MANUSCRIPT_CONFIG$networks$id)
    rdas_to_include <- sprintf('%d.RData', MANUSCRIPT_CONFIG$networks$id)

    input_nets <- input_nets[basename(input_nets) %in% nets_to_include] 
    input_rdas <- input_rdas[basename(input_rdas) %in% rdas_to_include] 
}

# load adjacency matrix and module mapping for the first network
load(input_rdas[1])

# use module mapping to determine adjacency matrix dimensions
matsize <- nrow(module_mapping)

# create empty adjacency matrix from first network
adjmat <- matrix(0, nrow=matsize, ncol=matsize)

# note, genes are stored in the same order in the adjacency matrix and the
# module mapping, so we can infer id's from the mapping
rownames(adjmat) <- module_mapping$gene_id
colnames(adjmat) <- module_mapping$gene_id

# empty vectors to keep track of network metrics
network_densities    <- c()
ratio_nonzero_edges  <- c()
ratio_edges_1q       <- c()
ratio_edges_2q       <- c()
ratio_edges_3q       <- c()
median_edge_weight_global   <- c()
median_ratio_edges_per_gene <- c() 
median_edge_weight_per_gene <- c() 

# iterate over remaining networks and add to consensus net
for (i in 1:length(input_nets)) {
    # load saved data
    message(sprintf("Loading network %d/%d", i, length(input_nets)))

    load(input_nets[i])
    load(input_rdas[i])


    # reconstruct adjacency matrix
    matsize <- nrow(module_mapping)

    # check to make sure dimensions are as expected (a few adjacency matrices
    # in the past were corrupted, leading to issues; has since been fixed
    # upstream..)
    if ((((matsize * matsize) - matsize) / 2) != length(adjacency_matrix)) {
        warning(sprintf("Dimension mismatch for adjacency matrix: %s", 
                        input_rdas[i]))
        stop(sprintf("Incompatible adjacency matrix input: %s", input_nets[i]))
    }

    # save a non-normalized version of network for computing network metrics
    raw_adjacency_matrix <- adjacency_matrix

    # convert upper.tri weight vector back into adj matrix (raw)
    raw_adj <- matrix(0, nrow=matsize, ncol=matsize)
    raw_adj[upper.tri(raw_adj)] <- raw_adjacency_matrix
    raw_adj[lower.tri(raw_adj)] <- t(raw_adj)[lower.tri(raw_adj)]

    rownames(raw_adj) <- module_mapping$gene_id
    colnames(raw_adj) <- module_mapping$gene_id

    g <- graph.adjacency(raw_adj, mode='undirected', weighted=TRUE)

    # compute network metrics

    # network density
    # http://igraph.org/r/doc/edge_density.html
    network_densities <- c(network_densities, edge_density(g))
    rm(g)

    # ratio of non-zero edges (global)
    ratio_nonzero_edges <- c(ratio_nonzero_edges, sum(raw_adjacency_matrix != 0) / length(raw_adjacency_matrix))

    # ratio of edges with values > 0.25, 0.50, 0.75
    ratio_edges_1q <- c(ratio_edges_1q, sum(raw_adjacency_matrix > 0.25) / length(raw_adjacency_matrix))
    ratio_edges_2q <- c(ratio_edges_2q, sum(raw_adjacency_matrix > 0.50) / length(raw_adjacency_matrix))
    ratio_edges_3q <- c(ratio_edges_3q, sum(raw_adjacency_matrix > 0.75) / length(raw_adjacency_matrix))

    # median non-zero edge weight value (global)
    median_edge_weight_global <- c(median_edge_weight_global, median(raw_adjacency_matrix[raw_adjacency_matrix != 0]))

    # median ratio of non-zero edges per gene
    median_ratio_edges_per_gene <- c(median_ratio_edges_per_gene, 
                                     median(apply(raw_adj, 1, function(x) { sum(x != 0) / nrow(raw_adj) })))

    median_edge_weight_per_gene <- c(median_edge_weight_per_gene, 
                                     median(apply(raw_adj, 1, function(x) { median(x[x != 0]) })))

    # http://igraph.org/r/doc/transitivity.html
    # doesn't work as expected with dense weighted networks 
    # (and long run-time); disabling for now
    # clustering_coefs <- c(clustering_coefs, transitivity(g, type='weighted'))

    # network betweeness centrality
    # http://igraph.org/r/doc/centr_betw.html
    # centr_betw(g, directed=FALSE)
    # ~1-2 hrs
    #network_centralities <- c(network_centralities, centr_betw(g, directed=FALSE)$centralization)

    # network diameter
    # diameter(g, directed=FALSE)  ; will use "weight" attrib of edges..
    # > 8 hrs
    #network_diameters <- c(network_diameters, diameter(g, directed=FALSE))

    # mean_distance (unweighted)
    #average_path_lengths <- c(average_path_lengths, mean_distance(g, directed=FALSE)) 

    rm(raw_adjacency_matrix)
    rm(raw_adj)

    # normalize edge weights
    if ('normalization' %in% names(MANUSCRIPT_CONFIG)) {
        if (MANUSCRIPT_CONFIG$normalization == 'scale') {
            # size-factor normalization
            adjacency_matrix <- (adjacency_matrix / sum(adjacency_matrix)) * 1E6
        } else if (MANUSCRIPT_CONFIG$normalization == 'rank') {
            adjacency_matrix <- rank(adjacency_matrix) * 1E-5
        }
    }

    # convert upper.tri weight vector back into adj matrix (normalized)
    tmp <- matrix(0, nrow=matsize, ncol=matsize)
    tmp[upper.tri(tmp)] <- adjacency_matrix
    tmp[lower.tri(tmp)] <- t(tmp)[lower.tri(tmp)]

    rownames(tmp) <- module_mapping$gene_id
    colnames(tmp) <- module_mapping$gene_id

    # check dimensions
    if ((nrow(adjmat) != nrow(tmp)) || (!all(rownames(adjmat) == rownames(tmp)))) {
        # normalize matrix size and elements
        tmp_missing <- rownames(adjmat)[!rownames(adjmat) %in% rownames(tmp)]
        if (length(tmp_missing) > 0) {
            # add missing columns / rows
            gene_ids <- rownames(tmp)

            tmp <- rbind(tmp, matrix(0, nrow=length(tmp_missing), ncol=ncol(tmp)))
            tmp <- cbind(tmp, matrix(0, nrow=nrow(tmp), ncol=length(tmp_missing)))

            rownames(tmp) <- c(gene_ids, tmp_missing)
            colnames(tmp) <- c(gene_ids, tmp_missing)

        }

        adj_missing <- rownames(tmp)[!rownames(tmp) %in% rownames(adjmat)]
        if (length(adj_missing) > 0) {
            # add missing columns / rows
            gene_ids <- rownames(adjmat)

            adjmat <- rbind(adjmat, matrix(0, nrow=length(adj_missing), ncol=ncol(adjmat)))
            adjmat <- cbind(adjmat, matrix(0, nrow=nrow(adjmat), ncol=length(adj_missing)))

            rownames(adjmat) <- c(gene_ids, adj_missing)
            colnames(adjmat) <- c(gene_ids, adj_missing)
        }

        # normalize row/column order
        tmp <- tmp[order(rownames(tmp)),order(colnames(tmp))]
        adjmat <- adjmat[order(rownames(adjmat)),order(colnames(adjmat))]
    }

    # combine matrices
    adjmat <- adjmat + tmp
}

# histogram of the consensus adj matrix edge weight distribution
#hist(log1p(adjmat))
hist(adjmat, main="Distribution of consensus adjacency matrix edge weights",
     xlab="Edge weight")
```

